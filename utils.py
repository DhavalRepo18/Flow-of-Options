"""
Module for logging, code management, visualization, and execution of Python scripts.

This module provides utility functions to log responses to files, save generated code,
create visual representations of Flow-of-Options as directed graphs, and execute Python scripts
while capturing output and errors. It is designed to support task planning and execution systems
by providing visual insight into the graph structures of FoO and capturing the execution status
of the code produced by FoO.

Functions:
    log_response(
        log_folder: str,
        output: str,
        cost: float = None,
        input: str = "",
        new_file: bool = False
    ) -> None:
        Logs responses, inputs, and costs into a text file within a specified folder.

    save_generated_code(log_folder: str, code_fname: str, code: str) -> None:
        Saves a string of generated Python code to a file in a specified location.

    create_foo_graph(
        graph: dict[str, list[str]],
        num_visited: dict[str, int],
        fname: str,
        invalid_paths: list[list[str]] = []
    ) -> None:
        Generates a visual representation of a directed graph (Flow-of-Options)
        and saves it as an image file, optionally highlighting invalid paths.

    execute_code(log_folder: str, code_fname: str) -> tuple[str, int]:
        Executes a Python script, capturing the standard output or error message,
        and returns the output or error along with the return code.

Use Cases:
    - Logging program outputs, inputs, and associated costs for auditing and monitoring purposes.
    - Saving code generated by automated systems to a file for further use or analysis.
    - Visualizing complex decision flow structures, useful for identifying pathways and bottlenecks.
    - Executing Python scripts programmatically and handling any execution errors or timeouts.
"""


import os
import networkx as nx
import matplotlib.pyplot as plt
import textwrap
from matplotlib.gridspec import GridSpec
import subprocess
from networkx.drawing.nx_pydot import graphviz_layout
import config as cfg


def log_response(
	log_folder: str,
	output: str,
	cost: float=None,
	input: str="",
	new_file: bool=False
) -> None:
	# Log responses into a folder
	mode = 'a' if not new_file else 'w'
	with open(f'{log_folder}/log.txt', mode) as f:
		if input:
			f.write(input + "\n")
			f.write("".join(["-"] * 50) + "\n")

		f.write(output + "\n")

		if cost is not None:
			f.write(f"Cost so far: {cost}\n")

		f.write("".join(["#"] * 50) + "\n")
	f.close()


def save_generated_code(log_folder: str, code_fname: str, code: str) -> None:
	# Save the generated Python code
	full_path = os.path.join(log_folder, code_fname)
	with open(full_path, "w") as f:
		f.write(code)
	f.close()
      

def wrap_text(text: str, width: int=60) -> str:
    # Function to wrap long text (e.g., to fit into the visualized nodes of the FoO)
    return "\n".join(textwrap.wrap(text, width))


def convert_invalid_FoO_paths_to_readable_text(invalid_paths: list, label_to_int: list) -> str:
    """Paths through FoO is a list of nodes. We convert them to a readable text format
    based on what the nodes represent.
    """
    invalid_edges = []
    for ip in invalid_paths:
        s = ""
        for i in range(len(ip)):
            node_int = label_to_int[ip[i]]
            if i < len(ip) - 1:
                s += f"{node_int} -> "
            else:
                s += f"{node_int} | "
        invalid_edges.append(s + "\n")
    invalid_edges = list(set(invalid_edges))
    invalid_edges = "".join(invalid_edges)
    invalid_edges = "Invalid Edges: " + invalid_edges
    return invalid_edges


def create_foo_graph(
    graph: dict[str, list[str]], num_visited: dict[str, int], fname: str, invalid_paths: list[list[str]]
) -> None:
    """Visualize the Flow-of-options as a directed graph.

    Args:
        graph (dict): FoO datastructure denoting the nodes and edges.
        num_visited (dict): Mapping from nodes to number of times that node was visited during traversal.
        fname (str): Name of file to save the visualization as.
        invalid_paths (list): List of paths along FoO that are not valid or are inconsistent.

    Returns:
        None: Saves the visualizations into the specified file name.
    """

    # Create a directed graph
    G = nx.DiGraph()

    # Map long string labels to integer labels
    label_to_int = {label: idx for idx, label in enumerate(graph)}
    int_to_label = {idx: label for label, idx in label_to_int.items()}

    # Add nodes and edges using integer labels
    for src, targets in graph.items():
        src_int = label_to_int[src]
        for tgt, weight in targets:
            tgt_int = label_to_int[tgt]
            G.add_edge(src_int, tgt_int, weight=weight)

    if invalid_paths:
        # Convert invalid paths into readable text
        invalid_edges = convert_invalid_FoO_paths_to_readable_text(invalid_paths, label_to_int)

    # Wrap each long label for display
    wrapped_int_to_label = {idx: wrap_text(label) for idx, label in int_to_label.items()}

    # Plot the graph
    if invalid_paths:
        fig = plt.figure(figsize=(20, 10))
        gs = GridSpec(1, 3, width_ratios=[3, 3, 1])
    else:
        fig = plt.figure(figsize=(20, 10))
        gs = GridSpec(1, 2, width_ratios=[1, 1])

    # Plot the graph with integer node labels
    ax1 = fig.add_subplot(gs[0, 0])
    pos = graphviz_layout(G, prog="dot")
    nx.draw(
        G,
        pos,
        ax=ax1,
        with_labels=True,
        labels={node: f"{node} : {num_visited[int_to_label[node]]}" for node in G.nodes()},
        node_size=[4500 for _ in range(len(G.nodes()))],
        node_color='#8BB7DF'
    )

    # Extract and draw edge labels
    edge_labels = {(u, v): f"{d['weight']:.3f}" for u, v, d in G.edges(data=True)}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, ax=ax1, label_pos=0.7)

    ax1.set_title('Graph with Integer Labels')

    # Plot the integer-to-long-label mapping
    ax2 = fig.add_subplot(gs[0, 1])
    mapping_text = "\n\n".join([f"{idx}: {wrapped_int_to_label[idx]}" for idx in sorted(wrapped_int_to_label)])
    ax2.text(0.5, 0.5, mapping_text, verticalalignment='center', horizontalalignment='center',
            transform=plt.gca().transAxes, fontsize=10, bbox=dict(facecolor='wheat', alpha=0.5))
    
    ax2.axis('off')
    
    # Note invalid paths
    if invalid_paths:   
        ax3 = fig.add_subplot(gs[0, 2])
        ax3.text(0.1, 0.85, wrap_text(invalid_edges), color='r')
        ax3.axis('off')

    plt.tight_layout()
    plt.savefig(fname)


def execute_code(log_folder: str, code_fname: str) -> tuple[str, int]:
	full_path = os.path.join(log_folder, code_fname)
	try:
		# Execute the script using subprocess.run and capture the output and any errors
		result = subprocess.run(
			['python', full_path],
			text=True,            # Ensures that the output is returned as a string
			capture_output=True,  # Captures stdout and stderr
			timeout=cfg.TIMEOUT   # Timeout setting for code execution
		)

		# Check for errors
		if result.returncode == 0:
			# Return the output if no error occurred
			return f"{result.stdout}", result.returncode
		else:
			# Return the error message if an error occurred
			return f"{result.stderr}", result.returncode

	except Exception as e:
		return f"Exception occurred: {str(e)}", 1
